# 二进制、字符串和字符列表

1.UTF-8和Unicode
2.二进制数(以及位串)
3.字符列表

在“基本类型”一章中，我们学习了字符串的只是，还使用`is_binary/1`函数进行检查：

```elixir
iex> string = "hello"
"hello"
iex> is_binary(string)
true
```

本章我们将学习什么是二进制数，它们和字符串之间的关联和类似`'like this'`这种被单引号包裹的值在Elixir中是什么。

## UTF-8和Unicode

一个字符串是一个被编码成UTF-8的二进制数。为了理解这么说到底是什么意思，我们需要理解字节和码点的区别。

Unicode编码标准为我们所知道的很很多字符分配代码点。比如，字符`a`的码点是97，而字符`ł`是322。当向磁盘写入字符串`hełło`的时候，我们需要把这些码点转换成字节。如果我们采用的规则是一个字节代表一个码点，那么我们无法写入`"hełło"`，因为`ł`的码点是322，而一个字节只能表示`0`-`255`的范围。当然，之所以你能看到`"hełło"`显示在你的屏幕上是因为必须以某种方式来处理这种情况，这就是编码起作用的地方。

当用字节来表示码点，我们需要以某种方式来编码它们。Elixir使用UTF-8作为主要和默认的编码方案。当我们说一个字符串是一个UTF-8编码的二进制数据时，我们实际上是在说一个字符串是一些其码点被作为UTF-8编码的字节。

`ł`的码点是322，我们实际上需要使用大于一个字节的数据来表示它。这就是为什么对一个字符串调用`byte_size/1`和`String.length/1`的结果有可能不同的原因。

```elixir
iex> string = "hełło"
"hełło"
iex> byte_size(string)
7
iex> String.length(string)
5
```

这里，`byte_size/1`计算的是字符串的字节数，而`String.length/1`计算的是字符数。

> 注意：如果你在Windows环境下，你有机会改变终端使用的字符集，不使用UTF-8。你可以在进入IEx之前在当前命令行下运行`chcp 65001`。

UTF-8在表示字符`h`、`e`和`o`时需要一个字节，而表示`ł`则需要两个字节。在Elixir中，你可以使用`?`来获得一个字符的码点：

```elixir
iex> ?a
97
iex> ?ł
322
```

你也可以使用`String`模块的函数来基于字符分割一个字符串，每个字符的字符长度为1：

```elixir
iex> String.codepoints("hełło")
["h", "e", "ł", "ł", "o"]
```

你将会看到Elixir对字符串提供了非常良好的支持。Elixir还支持很多Unicode的操作。实际上，Elixir在["The string type is broken"](http://mortoray.com/2013/11/27/the-string-type-is-broken/)中展示了所有的测试用例。

然而，字符串仅仅是我们要讨论的一部分。如果一个字符串是一个二进制数据，并且我们使用过`is_binary/1`函数处理字符串，则Elixir必须在底层提供一个能够支持字符串的类型。没错，事实就是这样！让我们来看看二进制型。

## 二进制型（和位串）

在Elixir中，我们可以使用`<<>>`来定义一个二进制型：

```elixir
iex> <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> byte_size(<<0, 1, 2, 3>>)
4
```

一个二进制型是一个字节序列。其中的字节可以被视为任何东西，甚至这个字节序列根本不是一个合法的字符串：

```elixir
iex> String.valid?(<<239, 191, 191>>)
false
```

字符串连接操作实际上就是二进制型的连接操作：

```elixir
iex> <<0, 1>> <> <<2, 3>>
<<0, 1, 2, 3>>
```

一个常见的技巧是，用连接字符串和空字节`<<0>>`这种方式来查看一个字符串的内部二进制型表示：

```elixir
iex> "hełło" <> <<0>>
<<104, 101, 197, 130, 197, 130, 111, 0>>
```

二进制型中的每个数字都表示一个字节，因此每个数字的最大值是255。二进制型允许传递一个修饰符来存储大于255的值，或者把一个码点转换成UTF-8表示：

```elixir
iex> <<255>>
<<255>>
iex> <<256>> # truncated
<<0>>
iex> <<256 :: size(16)>> # use 16 bits (2 bytes) to store the number
<<1, 0>>
iex> <<256 :: utf8>> # the number is a code point
"Ā"
iex> <<256 :: utf8, 0>>
<<196, 128, 0>>
```

一个字节有8比特，如果我们把size设置为1会发生什么？

```elixir
iex> <<1 :: size(1)>>
<<1::size(1)>>
iex> <<2 :: size(1)>> # truncated
<<0::size(1)>>
iex> is_binary(<<1 :: size(1)>>)
false
iex> is_bitstring(<<1 :: size(1)>>)
true
iex> bit_size(<< 1 :: size(1)>>)
1
```

这样的值不再是一个二进制型，而是一个位串——一堆比特位！所以当一个二进制型的位数不能被8整除时，它是一个位串。

```elixir
iex>  is_binary(<<1 :: size(16)>>)
true
iex>  is_binary(<<1 :: size(15)>>)
false
```

我们同样可以对二进制数据或位串进行模式匹配：

```elixir
iex> <<0, 1, x>> = <<0, 1, 2>>
<<0, 1, 2>>
iex> x
2
iex> <<0, 1, x>> = <<0, 1, 2, 3>>
** (MatchError) no match of right hand side value: <<0, 1, 2, 3>>
```

请注意，在二进制模式中，每个项将恰好匹配8位。如果我们想要匹配未知位数的二进制型，可以在模式后面传递一个二进制型修饰符：

```elixir
iex> <<0, 1, x :: binary>> = <<0, 1, 2, 3>>
<<0, 1, 2, 3>>
iex> x
<<2, 3>>
```

在字符串连接操作`<>`中，也可以实现类似的效果：

```elixir
iex> "he" <> rest = "hello"
"hello"
iex> rest
"llo"
```

可以在[Elixir文档](https://hexdocs.pm/elixir/Kernel.SpecialForms.html#%3C%3C%3E%3E/1)中找到完整的二进制型/位串构造器`<<>>`的参考文档。它总结了位串、二进制型和字符串的内容。一个字符串是一个UTF-8编码的二进制型，一个二进制型是一个位数能被8整除的位串。虽然这些东西展示了Elixir在处理位和字节时的灵活性，但99%的情况下你只会使用`is_binary/1`和`byte_size/1`函数和二进制型打交道。

## 字符列表

字符列表只不过是一个码点的列表。可以使用单引号包裹的字符串来创建字符列表：

```elixir
iex> 'hełło'
[104, 101, 322, 322, 111]
iex> is_list 'hełło'
true
iex> 'hello'
'hello'
iex> List.first('hello')
104
```

如你所见，一个字符列表使用单引号包裹，其中包含的是码点而不是字节（注意，默认情况下，如果码点表示的数值超过ASCII码的范围，IEx只会显示码点的整型表示）。所以，双引号表示一个字符串(即一个二进制型)，单引号表示一个字符列表（即一个列表）

实践中，字符列表经常被用于和Erlang交互，因为在一些特定的早期库中，不接受二进制型数据作为参数。你可以用`to_string/1`函数和`to_charlist/1`函数来实现一个字符列表和一个字符串的双向转换：

```elixir
iex> to_charlist "hełło"
[104, 101, 322, 322, 111]
iex> to_string 'hełło'
"hełło"
iex> to_string :hello
"hello"
iex> to_string 1
"1"
```

请注意，这些函数是多态的。它们不仅仅可以被用来把字符列表转换成字符串，还可以把整型、原子和其他类型转换成字符串。

学习了二进制型、字符串和字符列表以后，是时候来讨论一下键-值数据结构了。
